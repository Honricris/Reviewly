import React, { useState, useEffect } from 'react';
import Header from '../../components/Header';
import '../../styles/AdminDashboard.css';
import '../../styles/ReportGenerator.css';
import userService from '../../services/userService';
import { getProducts, getCategories } from '../../services/productService';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

const ReportGeneratorPage = () => {
  const [reportType, setReportType] = useState<string>('');
  const [formData, setFormData] = useState<any>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [categories, setCategories] = useState<string[]>([]);
  const [categoriesLoading, setCategoriesLoading] = useState(false);

  const reportOptions = [
    { value: 'user_activity', label: 'User Activity Report' },
    { value: 'product_popularity', label: 'Product Popularity Report' },
  ];

  useEffect(() => {
    if (reportType === 'product_popularity') {
      fetchCategories();
    }
  }, [reportType]);

  const fetchCategories = async () => {
    setCategoriesLoading(true);
    try {
      const categoriesData = await getCategories();
      setCategories(categoriesData);
    } catch (err) {
      setError('Failed to load categories');
    } finally {
      setCategoriesLoading(false);
    }
  };

  const handleReportTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setReportType(e.target.value);
    setFormData({});
    setError(null);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
  };

  const addHeaderFooter = (doc: jsPDF, title: string, pageNumber: number) => {
    doc.setFontSize(18);
    doc.setTextColor(40, 74, 112);
    doc.setFont('helvetica', 'bold');
    doc.text(title, 20, 20);
    doc.setFontSize(10);
    doc.setTextColor(100);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 20, 30);
    doc.line(20, 35, 190, 35);
    doc.setFontSize(8);
    doc.setTextColor(150);
    doc.text(`Page ${pageNumber}`, 190, 290, { align: 'right' });
    doc.text('Generated by Admin Dashboard', 20, 290);
    doc.line(20, 285, 190, 285);
  };

  const generateUserActivityReport = async (
    doc: jsPDF,
    pageNumber: number,
    parameters: any,
    addHeaderFooter: (doc: jsPDF, title: string, pageNumber: number) => void
  ) => {
    const users = await userService.getAllUsers();
    const { start_date: startDate, end_date: endDate, role } = parameters;

    const userDetailsWithLogs = await Promise.all(users.map(async (user) => {
      const loginLogs = await userService.getLoginLogs(user.id);
      return { user, loginLogs };
    }));

    const filteredUsers = startDate && endDate
      ? userDetailsWithLogs.filter(({ loginLogs }) =>
          loginLogs.some(log => {
            const loginDate = new Date(log.login_at);
            return loginDate >= new Date(startDate) && loginDate <= new Date(endDate);
          })
        ).map(({ user }) => user)
      : users;

    const finalUsers = role && role !== 'All' && role !== ''
      ? filteredUsers.filter(user => user.role === role)
      : filteredUsers;

    const userDetails = await Promise.all(finalUsers.map(async (user) => {
      const favorites = await userService.getFavorites(user.id);
      const queries = await userService.getRecentQueries(user.id);
      const loginLogs = await userService.getLoginLogs(user.id);
      return {
        ...user,
        favoriteCount: favorites.length,
        queryCount: queries.length,
        lastLogin: loginLogs.length > 0 ? loginLogs[loginLogs.length - 1].login_at : 'N/A',
      };
    }));

    addHeaderFooter(doc, 'User Activity Report', pageNumber);

    doc.setFontSize(12);
    doc.setTextColor(40);
    doc.text('Report Parameters', 20, 45);
    doc.setFontSize(10);
    doc.setTextColor(60);
    doc.text(`Login Date Range: ${startDate || 'All'} to ${endDate || 'All'}`, 20, 55);
    doc.text(`Role: ${role || 'All'}`, 20, 65);

    autoTable(doc, {
      startY: 75,
      head: [['ID', 'Email', 'Role', 'Created At', 'Favorites', 'Queries', 'Last Login']],
      body: userDetails.map(user => [
        user.id,
        user.email || 'N/A',
        user.role,
        user.created_at.split('T')[0],
        user.favoriteCount,
        user.queryCount,
        user.lastLogin.split('T')[0] || 'N/A',
      ]),
      styles: { fontSize: 10, cellPadding: 3, textColor: [60], fillColor: [245, 245, 245] },
      headStyles: { fillColor: [40, 74, 112], textColor: [255], fontStyle: 'bold' },
      alternateRowStyles: { fillColor: [230, 230, 230] },
      margin: { top: 75, left: 20, right: 20 },
      didDrawPage: (data: any) => {
        pageNumber++;
        addHeaderFooter(doc, 'User Activity Report', pageNumber);
      }
    });
  };

  const generateProductPopularityReport = async (
    doc: jsPDF,
    pageNumber: number,
    parameters: any,
    addHeaderFooter: (doc: jsPDF, title: string, pageNumber: number) => void
  ) => {
    const { 
      category, 
      min_price: minPrice, 
      max_price: maxPrice, 
      min_rating: minRating, 
      min_favorites: minFavorites, 
      sort_by: sortBy,
      sort_order: sortOrder = 'asc'
    } = parameters;
    
    const productData = await getProducts(1, 100, category, undefined, minPrice, maxPrice, undefined, undefined, undefined, true);

    let filteredProducts = productData.products;
    if (minRating) {
      filteredProducts = filteredProducts.filter(p => p.average_rating >= minRating);
    }
    if (minFavorites) {
      filteredProducts = filteredProducts.filter(p => p.favorite_count >= minFavorites);
    }

    const sortDirection = sortOrder === 'desc' ? -1 : 1;

    switch (sortBy) {
      case 'favorites':
        filteredProducts.sort((a, b) => (b.favorite_count - a.favorite_count) * sortDirection);
        break;
      case 'rating':
        filteredProducts.sort((a, b) => (b.average_rating - a.average_rating) * sortDirection);
        break;
      case 'reviews':
        filteredProducts.sort((a, b) => (b.rating_number - a.rating_number) * sortDirection);
        break;
      case 'price':
        filteredProducts.sort((a, b) => (a.price - b.price) * sortDirection);
        break;
      default:
        filteredProducts.sort((a, b) => a.title.localeCompare(b.title) * sortDirection);
    }

    addHeaderFooter(doc, 'Product Popularity Report', pageNumber);

    doc.setFontSize(12);
    doc.setTextColor(40);
    doc.text('Report Parameters', 20, 45);
    doc.setFontSize(10);
    doc.setTextColor(60);
    doc.text(`Category: ${category || 'All'}`, 20, 55);
    doc.text(`Price Range: ${minPrice || 'Any'} - ${maxPrice || 'Any'}`, 20, 60);
    doc.text(`Min Rating: ${minRating || 'Any'}`, 20, 65);
    doc.text(`Min Favorites: ${minFavorites || 'Any'}`, 20, 70);
    doc.text(`Sort By: ${sortBy || 'Title'} (${sortOrder})`, 20, 75);

    autoTable(doc, {
      startY: 85,
      head: [['Title', 'Price', 'Rating', 'Favorites', 'Reviews']],
      body: filteredProducts.map((p: any) => [
        p.title.length > 50 ? p.title.substring(0, 47) + '...' : p.title,
        `$${p.price.toFixed(2)}`,
        p.average_rating.toFixed(1),
        p.favorite_count,
        p.rating_number,
      ]),
      styles: { fontSize: 10, cellPadding: 3, textColor: [60], fillColor: [245, 245, 245] },
      headStyles: { fillColor: [40, 74, 112], textColor: [255], fontStyle: 'bold' },
      alternateRowStyles: { fillColor: [230, 230, 230] },
      margin: { top: 85, left: 20, right: 20 },
      didDrawPage: (data: any) => {
        pageNumber++;
        addHeaderFooter(doc, 'Product Popularity Report', pageNumber);
      }
    });
  };

  const generatePDF = async () => {
    setLoading(true);
    setError(null);
    try {
      const doc = new jsPDF();
      let pageNumber = 1;

      switch (reportType) {
        case 'user_activity':
          await generateUserActivityReport(doc, pageNumber, formData, addHeaderFooter);
          break;
        case 'product_popularity':
          await generateProductPopularityReport(doc, pageNumber, formData, addHeaderFooter);
          break;
        default:
          throw new Error('Invalid report type');
      }
      doc.save(`${reportType}_report_${new Date().toISOString().split('T')[0]}.pdf`);
    } catch (err) {
      setError('Error generating report');
    } finally {
      setLoading(false);
    }
  };

  const renderForm = () => {
    switch (reportType) {
      case 'user_activity':
        return (
          <>
            <div className="form-group">
              <label>Start Date</label>
              <input
                type="date"
                name="start_date"
                value={formData.start_date || ''}
                onChange={handleInputChange}
              />
            </div>
            <div className="form-group">
              <label>End Date</label>
              <input
                type="date"
                name="end_date"
                value={formData.end_date || ''}
                onChange={handleInputChange}
              />
            </div>
            <div className="form-group">
              <label>Role</label>
              <select name="role" value={formData.role || ''} onChange={handleInputChange}>
                <option value="">All Roles</option>
                <option value="user">User</option>
                <option value="admin">Admin</option>
              </select>
            </div>
          </>
        );
      case 'product_popularity':
        return (
          <>
            <div className="form-group">
              <label>Category</label>
              <select
                name="category"
                value={formData.category || ''}
                onChange={handleInputChange}
                disabled={categoriesLoading}
              >
                <option value="">All Categories</option>
                {categories.map(category => (
                  <option key={category} value={category}>
                    {category}
                  </option>
                ))}
              </select>
              {categoriesLoading && <span>Loading categories...</span>}
            </div>

            <div className="form-group">
              <label>Price Range</label>
              <div className="range-inputs">
                <input
                  type="number"
                  name="min_price"
                  value={formData.min_price || ''}
                  onChange={handleInputChange}
                  placeholder="Min Price (Optional)"
                  min="0"
                />
                <span>to</span>
                <input
                  type="number"
                  name="max_price"
                  value={formData.max_price || ''}
                  onChange={handleInputChange}
                  placeholder="Max Price (Optional)"
                  min="0"
                />
              </div>
            </div>

            <div className="form-group">
              <label>Min Rating</label>
              <input
                type="number"
                name="min_rating"
                value={formData.min_rating || ''}
                onChange={handleInputChange}
                placeholder="0-5 (Optional)"
                min="0"
                max="5"
                step="0.1"
              />
            </div>

            <div className="form-group">
              <label>Min Favorites</label>
              <input
                type="number"
                name="min_favorites"
                value={formData.min_favorites || ''}
                onChange={handleInputChange}
                placeholder="Minimum favorites (Optional)"
                min="0"
              />
            </div>

            <div className="form-group">
              <label>Sort By</label>
              <div className="sort-container">
                <select
                  name="sort_by"
                  value={formData.sort_by || 'title'}
                  onChange={handleInputChange}
                >
                  <option value="title">Title</option>
                  <option value="price">Price</option>
                  <option value="favorites">Favorites</option>
                  <option value="rating">Rating</option>
                  <option value="reviews">Reviews</option>
                </select>
                <select
                  name="sort_order"
                  value={formData.sort_order || 'asc'}
                  onChange={handleInputChange}
                >
                  <option value="asc">Ascending</option>
                  <option value="desc">Descending</option>
                </select>
              </div>
            </div>
          </>
        );
      default:
        return null;
    }
  };

  return (
    <div className="admin-dashboard">
      <Header
        buttonConfig={{ showHome: true, showFavourites: false, showLogout: true, isAdmin: true }}
        showSearchBar={false}
      />
      <div className="dashboard-container">
        <div className="report-generator-page">
          <select
            value={reportType}
            onChange={handleReportTypeChange}
            className="report-select"
          >
            <option value="">Select Report Type</option>
            {reportOptions.map(option => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
          {reportType && (
            <div className="report-form">
              {renderForm()}
              <button
                className="generate-btn"
                onClick={generatePDF}
                disabled={loading}
              >
                {loading ? 'Generating...' : 'Generate PDF'}
              </button>
            </div>
          )}
          {error && <div className="error-message">{error}</div>}
        </div>
      </div>
    </div>
  );
};

export default ReportGeneratorPage;